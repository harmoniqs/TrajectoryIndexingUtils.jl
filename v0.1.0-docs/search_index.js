var documenterSearchIndex = {"docs":
[{"location":"lib/#TrajectoryIndexingUtils-methods","page":"Library","title":"TrajectoryIndexingUtils methods","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"This module contains helper functions for indexing and taking slices of the full problem variable vector definitions:","category":"page"},{"location":"lib/","page":"Library","title":"Library","text":"problem vector:    Z = [z₁, z₂, ..., zₜ]\nknot point:   zₜ = [xₜ, uₜ]\naugmented state vector:   xₜ = [ψ̃ₜ, ψ̃²ₜ, ..., ψ̃ⁿₜ, ∫aₜ, aₜ, daₜ, ..., dᶜ⁻¹aₜ]","category":"page"},{"location":"lib/","page":"Library","title":"Library","text":"where c = control_order","category":"page"},{"location":"lib/","page":"Library","title":"Library","text":"also, below, we use dim(zₜ) = dim examples:","category":"page"},{"location":"lib/","page":"Library","title":"Library","text":"Z[index(t, pos, dim)]               = zₜ[pos]\nZ[index(t, dim)]                    = zₜ[dim]\nZ[slice(t, pos1, pos2, dim)]        = zₜ[pos1:pos2]\nZ[slice(t, pos, dim)]               = zₜ[1:pos]\nZ[slice(t, dim)]                    = zₜ[1:dim] := zₜ\nZ[slice(t, dim; stretch=stretch)]   = zₜ[1:(dim + stretch)]\nZ[slice(t, indices, dim)]           = zₜ[indices]\nZ[slice(t1:t2, dim)]                = [zₜ₁;...;zₜ₂]","category":"page"},{"location":"lib/","page":"Library","title":"Library","text":"The functions are also used to access the zₜ vectors, e.g.","category":"page"},{"location":"lib/","page":"Library","title":"Library","text":"zₜ[slice(i, isodim)]                             = ψ̃ⁱₜ\nzₜ[n_wfn_states .+ slice(1, ncontrols)]          = ∫aₜ\nzₜ[n_wfn_states .+ slice(2, ncontrols)]          = aₜ\nzₜ[n_wfn_states .+ slice(augdim + 1, ncontrols)] = uₜ = ddaₜ","category":"page"},{"location":"lib/","page":"Library","title":"Library","text":"Examples below are run with:","category":"page"},{"location":"lib/","page":"Library","title":"Library","text":"using TrajectoryIndexingUtils\nZ = collect(1.5:12.5)  # Example vector as Float64\ndim = 3  # Example dimension","category":"page"},{"location":"lib/#API","page":"Library","title":"API","text":"","category":"section"},{"location":"lib/#TrajectoryIndexingUtils.index-Tuple{Any, Any}","page":"Library","title":"TrajectoryIndexingUtils.index","text":"index(t::Int, dim::Int)\n\nCalculate the index in the full problem vector for a given time step t and dimension dim. Assumes pos is equal to dim.\n\njulia> Z[index(1, dim)]\n3.5\n\n\n\n\n\n","category":"method"},{"location":"lib/#TrajectoryIndexingUtils.index-Tuple{Int64, Int64, Int64}","page":"Library","title":"TrajectoryIndexingUtils.index","text":"index(t::Int, pos::Int, dim::Int)\n\nCalculate the index in the full problem vector for a given time step t, position pos, and dimension dim.\n\njulia> Z[index(1, 1, 3)]\n1.5\n\n\n\n\n\n","category":"method"},{"location":"lib/#TrajectoryIndexingUtils.slice-NTuple{4, Int64}","page":"Library","title":"TrajectoryIndexingUtils.slice","text":"slice(t::Int, pos1::Int, pos2::Int, dim::Int)\n\nCalculate slice of the full problem vector for a given time step t, starting position pos1, and ending position pos2.\n\njulia> Z[slice(2, 1, 3, 3)]\n3-element Vector{Float64}:\n 4.5\n 5.5\n 6.5\n\n\n\n\n\n","category":"method"},{"location":"lib/#TrajectoryIndexingUtils.slice-Tuple{Int64, AbstractVector{Int64}, Int64}","page":"Library","title":"TrajectoryIndexingUtils.slice","text":"slice(t::Int, indices::AbstractVector{Int}, dim::Int)\n\nCalculate slice of the problem vector for a given time step t and a vector of indices indices.\n\njulia> Z[slice(2, [1, 3], 3)]\n2-element Vector{Float64}:\n 4.5\n 6.5\n\n\n\n\n\n","category":"method"},{"location":"lib/#TrajectoryIndexingUtils.slice-Tuple{Int64, Int64, Int64}","page":"Library","title":"TrajectoryIndexingUtils.slice","text":"slice(t::Int, pos::Int, dim::Int)\n\nCalculate slice of the problem vector for a given time step t, up to position pos. Equivalent to slice(t, 1, pos, dim).'\n\njulia> Z[slice(2, 2, 3)]\n2-element Vector{Float64}:\n 4.5\n 5.5\n\n\n\n\n\n","category":"method"},{"location":"lib/#TrajectoryIndexingUtils.slice-Tuple{Int64, Int64}","page":"Library","title":"TrajectoryIndexingUtils.slice","text":"slice(t::Int, dim::Int; stretch=0)\n\nCalculate slice of the problem vector for a given time step t, with an optional stretch parameter\n\njulia> Z[slice(2, 3; stretch=1)]\n4-element Vector{Float64}:\n 4.5\n 5.5\n 6.5\n 7.5\n\n\n\n\n\n","category":"method"},{"location":"lib/#TrajectoryIndexingUtils.slice-Tuple{UnitRange{Int64}, Int64}","page":"Library","title":"TrajectoryIndexingUtils.slice","text":"slice(ts::UnitRange{Int}, dim::Int)\n\nCalculate slice of the problem vector for a range of time steps ts that covers each of the knot-points in those steps.\n\njulia> Z[slice(1:2, 3)]\n6-element Vector{Float64}:\n 1.5\n 2.5\n 3.5\n 4.5\n 5.5\n 6.5\n\n\n\n\n\n","category":"method"},{"location":"#TrajectoryIndexingUtils.jl","page":"Home","title":"TrajectoryIndexingUtils.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is a super lightweight package that exports two functions: index and slice.  These functions have helped to ease the burden of handling messy indexing into trajectory data vectors of the form ","category":"page"},{"location":"","page":"Home","title":"Home","text":"vec Z = textvecleft(z_1 z_2 ldots z_Tright) in mathbfR^T cdot d","category":"page"},{"location":"","page":"Home","title":"Home","text":"where each element z_t is referred to as a knot point and normally contains state variables and control variables. In a simple situation we might have z_t = textvec (x_t u_t) in mathbfR^d = n+m, for the state x_t in mathbfR^n and control u_t in mathbfR^m.  In this case, with  dim = n + m, we can use slice and index, to extract what we want from vec Z in the following way:","category":"page"},{"location":"","page":"Home","title":"Home","text":"extract z_t:   julia   zₜ = Z⃗[slice(t, dim)]\nextract x_t:   julia   xₜ = Z⃗[slice(t, 1:n, dim)]\nextract u_t:   julia   uₜ = Z⃗[slice(t, (1:m) .+ n, dim)]\nextract i-th component of x_t:   julia   xₜⁱ = Z⃗[index(t, i, dim)]\nextract j-th component of u_t:   julia   uₜʲ = Z⃗[index(t, j + n, dim)]","category":"page"},{"location":"","page":"Home","title":"Home","text":"With this, the user is still responsible for keeping track of the component indices for x and u, and possibly other variables. To alleviate this nuisance, the package NamedTrajectories.jl provides a richer alternative for handling trajectory data with arbitrarily named components, please check it out!","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TrajectoryIndexingUtils.jl is registered! Install in the REPL by entering pkg mode with ] and then running ","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add TrajectoryIndexingUtils","category":"page"},{"location":"#Methods","page":"Home","title":"Methods","text":"","category":"section"},{"location":"#The-index-function","page":"Home","title":"The index function","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"index(t::Int, dim::Int) -> zₜ[dim]\nindex(t::Int, pos::Int, dim::Int) -> zₜ[pos]","category":"page"},{"location":"#The-slice-function","page":"Home","title":"The slice function","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"slice(t::Int, dim::Int; stretch=0) -> zₜ[1:dim + stretch] # can be used to extract, e.g., [xₜ; xₜ₊₁], with stretch = dim\nslice(t::Int, pos::Int, dim::Int) -> zₜ[1:pos]\nslice(t::Int, pos1::Int, pos2::Int, dim::Int) -> zₜ[pos1:pos2]\nslice(t::Int, indices::AbstractVector{Int}, dim::Int) -> zₜ[indices]\nslice(ts::UnitRange{Int}, dim::Int) -> vec(zₜ for t ∈ ts)","category":"page"},{"location":"#Building-Documentation","page":"Home","title":"Building Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package uses a Documenter config that is shared with many of our other repositories. To build the docs, you will need to run the docs setup script to clone and pull down the utility. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"# first time only\n./docs/get_docs_utils.sh   # or ./get_docs_utils.sh if cwd is in ./docs/","category":"page"},{"location":"","page":"Home","title":"Home","text":"To build the docs pages:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --project=docs docs/make.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"or editing the docs live:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --project=docs\n> using LiveServer, Piccolo, Revise\n> servedocs(skip_files=[\"docs/src/index.md\"])","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note: servedocs needs to watch a subset of the files in the docs/ folder. If it watches files that are generated on a docs build/re-build, servedocs will continuously try to re-serve the pages.To prevent this, ensure all generated files are included in the skip dirs or skip files args for servedocs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For example, if we forget index.md like so:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --project=docs\n> using LiveServer, Piccolo, Revise\n> servedocs()","category":"page"},{"location":"","page":"Home","title":"Home","text":"it will not build and serve.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"\"It seems that perfection is attained not when there is nothing more to add, but when there is nothing more to take away.\" - Antoine de Saint-Exupéry","category":"page"}]
}
